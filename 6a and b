#include <stdio.h>
struct stock
{
int left;
int right;
int sum;
};
struct stock crosssubsum (int *a,int low,int mid,int high)
{
int leftsum=0,rightsum=0,sum=0,i,j,maxleft=0,maxright=0;
struct stock res;
for (i=mid;i>=low;i--)
{
sum = sum + a[i];
if (sum > leftsum)
{
leftsum = sum;
maxleft = i;
}
}
sum = 0;
for (j=mid+1;j<=high;j++)
{
sum = sum + a[j];
if (sum > rightsum)

{
rightsum = sum;
maxright = j;
}
}
res.left = maxleft;
res.right = maxright;
res.sum = leftsum+rightsum;
return res;
}
struct stock maxsubsum (int *a,int low,int high)
{
int mid;
struct stock leftsum,rightsum,crosssum,res;
if (low == high)
{
res.left = low;
res.right = high;
res.sum = a[low];
return res;
}
mid = (low+high)/2;
leftsum = maxsubsum( a,low,mid);
rightsum = maxsubsum (a,mid+1,high);
crosssum = crosssubsum (a,low,mid,high);
if (leftsum.sum >= rightsum.sum && leftsum.sum >=crosssum.sum)
return leftsum;
else if (rightsum.sum >= leftsum.sum && rightsum.sum >=crosssum.sum)
return rightsum;
else
return crosssum;
}
int main ()
{
int n,a[10],i,low,high;
struct stock maxsum;
printf ("Enter the no. of Days in Stock Market\n");
scanf ("%d",&n);
printf ("Enter the Gain or Loss in Stock Market per Day\n");
for (i=0;i<n;i++)
scanf ("%d",&a[i]);
low =0; high = n-1;
maxsum = maxsubsum (a,low,high);
printf ("Maximum Profit in Stock Market lies from Day %d to Day
%d\n",maxsum.left+1,maxsum.right+1);
printf ("Maximum Profit in Stock Market = %d\n",maxsum.sum);
return 0;
}



#include <stdio.h>
int BellmanFord (int G[20][20] ,int n,int E,int edge[20][2])
{
int i,u,v,k,distance[20],parent[20],S,D,flag=1;
for (i=0;i<n;i++)
{
distance[i] = 1000;
parent[i] = -1;
}
printf ("Enter Source\n");
scanf ("%d",&S);
printf ("Enter Destination\n");
scanf ("%d",&D);
printf ("Shortest Path from Source %d to Destination %d:\n",S,D);
distance[S-1] = 0;
for (i=0;i<n-1;i++)
{
for (k=0;k<E;k++)
{
u = edge[k][0];
v = edge[k][1];
if (distance[u]+G[u][v] < distance[v])
{
distance[v] = distance[u] + G[u][v];
parent[v] = u;
}
}
}
for(k=0;k<E;k++)
{
u = edge[k][0];
v = edge[k][1];

if (distance[u]+G[u][v] < distance[v])
flag = 0;
}
if (flag)
printf("Vertex %d -> Cost = %d Parent = %d\n",D,distance[D-1],parent[D-1]+1);
return flag;
}
int main ()
{
int n,edge[20][2],G[20][20],i,j,k=0;
printf ("Enter no. of Nodes in Graph\n");
scanf ("%d",&n);
printf ("Enter Cost Adjacency Matrix of Graph\n");
for (i=0;i<n;i++)
for (j=0;j<n;j++)
{
scanf ("%d",&G[i][j]);
if (G[i][j] != 0)                                                                                                                                                                                                                           
{
edge[k][0] = i;
edge[k++][1] = j;
}
}
if (BellmanFord(G,n,k,edge))
printf ("No negative weight cycle\n");
else
printf ("Negative weight cycle exists\n");
return 0;
}
